\section{Introduction}

For years, virtual machines served as a cornerstone of resource virtualization
both on premises and in cloud~\cite{rosenblum2005virtual}.
%
Recently, however, \emph{container-based} virtualization started to get
significant traction~\cite{process-containers-linux}.
%
According to polls, over 87\% of enterprises are at various stages of adopting
containers; analysts also predict that by 2020 containers will constitute a
lucrative \$2.5 billion market~\cite{container-grow-by2020}.
%
At its core, software container is a set of processes which operating system's
kernel isolates to provide them an illusion that they
%the containerized processes
use the system exclusively.
%
Linux, for instance, performs visibility isolation (for user identifiers, file systems,
network, etc.) using namespaces~\cite{man-namespaces} and enforces resource
utilization constraints with control groups~\cite{kernel-doc-cgroups}.
%
Compared to virtual machines, containers use less memory and storage, are much
faster to start, and typically cause less execution overhead.



Though much research was focused on various aspects of
containerization~\vcomment{Cite}, storage for containers remains an unexplored
territory~\cite{login-container-storage-options}.
%
To start designing a novel storage solution for containers,
or to optimize and fairly evaluate existing ones,
it is imperative to understand containers' real-world
use cases and workloads in sufficient details.
%
Unfortunately, little is known about how containers are used in the real world.
%
In part, this is due to the privacy concerns that organizations and individuals
have when sharing details of their computing environments.



Docker is another technology whose popularity grew rapidly in the recent
years~\cite{docker}.
%
It combines process containerization with efficient and effective runtime
environment packaging.
%
Docker packs software in \emph{images} each consisting of a manifest (which
describes, e.g., what command to start in the container) and several read-only
\emph{layers}.
%
Read-only layers can be shared between different images and encapsulate file-system
trees for dockerized processes.
%
When Docker starts a container, it combines read-only layers (and an additional
writable layer to store changes) into a single namespace and starts the process
declared in the manifest in the new namespace~\cite{docker-driver-eval}.



Docker images are stored at the centralized \emph{registry} and are pushed to
and pulled from the registry by clients as needed. 
%
The most known Docker registry installation is Docker Hub which according to
our estimates stores at least 400,000 \emph{public} images that consist of at
least 2,000,000 layers.
%
Our insight in this study is that this massive dataset can be used to understand what
applications run in containers, how much data they store, and the properties of
the data.




In this paper we perform first, comprehensive, large-scale characterization of
Docker registry contents.
%
We downloaded over 55TB of Docker images from Docker Hub and analyzed
traditional storage properties---e.g., file sizes and types, data compression
ratios, directory depths---as well as Docker-specific properties---e.g., the number
of layers per image and the amount of layer sharing.
%
We found, for example, XXX.
%
\vcomment{Here we need to stick an example or two of interesting findings.}


We believe our findings will improve the understanding of containers' data and lay
a solid ground for future storage optimizations at clients and registries in
Docker and beyond. The rest of the paper is organized as follows. We explain
relevant Docker details in Section~\ref{sec:background} and our methodology in
Section~\ref{sec:methodology}. We present dataset characterization in
Section~\ref{sec:results}, describe related work in Section~\ref{sec:related},
and conclude in Section~\ref{sec:conclusion}.
