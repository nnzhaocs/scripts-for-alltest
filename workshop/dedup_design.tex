\subsection{Design}
\label{sec:design}

We designed \sysname\ so that the interface between the Docker clients and the
registry remains the unchanged.
%
As such, no modifications are needed in the Docker clients.
%
Below we describe the actions that \sysname\ takes during the layer pushes and
pulls.
%
For the sake of this paper, we explain only the main steps omitting smaller
details.

\paragraph{Push}
%
\sysname\ does not unpack the layer immedieately after receiving it from a
client.
%
Instead, \sysname\ saves the layer's compressed tarball in a persistent
\emph{staging area}.
%
A separate \emph{off-line} deduplication process iterates over the layers in
the staging area and performs the following actions for every layer:
%
\textbf{1)}~uncompresses and unpacks the layer's tarball into individual files;
%
\textbf{2)}~computes a \emph{fingerprint} for every file in the layer;
%
\textbf{3)}~checks all file fingerprints against the \emph{file index} to
identify if identical files are already stored in \sysname;
%
\textbf{4)}~stores non-deduplicated files in \sysname's storage system;
%
\textbf{5)}~creates and stores a \emph{layer recipe} that includes the path,
metatada, and fingerprint of every file in the layer;
%
\textbf{6)}~removes the layer's tarball from the staging area.

Layer recipies are identified by layer's digests (see
Section~\ref{sec:background}) and files are identified by their fingeprints.
%
These identifiers are used by the underlying storage to store and retrieve
corresponding objects.
%
For example, if a file system is used as a backend storage, \sysname\ creates a
single file for layer reciepy (named by the fingerprint) and a single file for
actual in-layer file (named by the fingerprint).

\VT{Maybe discuss performance implications here. But maybe do it later. Will see.}

\paragraph{Pull}

FLCAS decompresses the layer archival files,
calculates the file content digests, searches whether the identical files are stored or not. 

If not, FLCAS stores these unique files.

%
Upon a pull request, FLCAS first restores the requested 
layer archival files by fetching all its containing files and compressing them.
%
How to manage layer-to-file mapping to provide fast searching \& indexing performance 
is also a challenging to FLCAS.

\LR{The challenges are not clear at this point. We need to first briefly describe the
overall approach, i.e. layer is pushed, archive is decompressed, file digests are
calculated, etc., and then say, what exactly is challenging/problematic about this
approach.}

\LR{We should also add the layer reconstruction as another challenge.}

\LR{Another challenge could be dealing with files that have same data but different
metadata.}\NZ{addressed}

%file-level deduplication not only includes calculation of file content digest, 
%searching for identical files, and storing unique files, 
%but also includes decompression of layer archival files and and restoring layer archival files.
%decompression of layer archival files,
%calculation of file content digest, 
%searching for identical files, 
%storing unique files,
%and restoring layer archival files.
%

te
%%%%% Overhead discussion

While FLCAS can significantly reduce the number of redundant files in the Docker
registry, it comes with several challenges, 
including file-level deduplication overhead and its impact on push or pull latencies.

These above operations are either CPU intensive or I/O intensive, which would impact 
the foreground push/pull requests.

The overhead of restoring a layer would become a bottleneck of a pull request.

\LR{The challenges should also be connected back to their effect, i.e. they will
affect push and pull latencies.}\NZ{addressed}


