\subsection{Design}
\label{sec:design}

%In this section we propose a file-level content addressable storage model (FLCAS)
%based on file-level deduplication
%for Docker as an alternative to layer-level content addressable storage.
%
%and save space while maintaing good
%FLCAS, can significantly reduce the redundant files in docker registry and save
%a large volume of storage space.
%

%%%%%% Design explanation

For example, after layers are pushed in registry, FLCAS decompresses the layer archival files,
calculates the file content digests, searches whether the identical files are stored or not. 

If not, FLCAS stores these unique files.

%
Upon a pull request, FLCAS first restores the requested 
layer archival files by fetching all its containing files and compressing them.
%
How to manage layer-to-file mapping to provide fast searching \& indexing performance 
is also a challenging to FLCAS.

\LR{The challenges are not clear at this point. We need to first briefly describe the
overall approach, i.e. layer is pushed, archive is decompressed, file digests are
calculated, etc., and then say, what exactly is challenging/problematic about this
approach.}

\LR{We should also add the layer reconstruction as another challenge.}

\LR{Another challenge could be dealing with files that have same data but different
metadata.}\NZ{addressed}

%file-level deduplication not only includes calculation of file content digest, 
%searching for identical files, and storing unique files, 
%but also includes decompression of layer archival files and and restoring layer archival files.
%decompression of layer archival files,
%calculation of file content digest, 
%searching for identical files, 
%storing unique files,
%and restoring layer archival files.
%


%%%%% Overhead discussion

While FLCAS can significantly reduce the number of redundant files in the Docker
registry, it comes with several challenges, 
including file-level deduplication overhead and its impact on push or pull latencies.

These above operations are either CPU intensive or I/O intensive, which would impact 
the foreground push/pull requests.

The overhead of restoring a layer would become a bottleneck of a pull request.

\LR{The challenges should also be connected back to their effect, i.e. they will
affect push and pull latencies.}\NZ{addressed}


