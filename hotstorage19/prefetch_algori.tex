\begin{algorithm}
\scriptsize 
	\caption{Preconstruction}
	\label{alg:prefetch}
	\KwIn{\\
		$\theta_{rpc}$: Threshold for repull layers to be preconstructed and cached. \\
		$RLmap$: Repository to layers map. \\
		$URLmap$: User to user profile map.  \\
	}
%	\SetKwFunction{FMain}{Precontruction}
%	\SetKwProg{Fn}{Function}{:}{}
%	\Fn{\FMain{}}{
	%\While{true}{
		\emph{r} $\leftarrow$ \texttt{request received}\\
		\uIf{r = GET manifest}
		{
			newLayers $\gets$ \emph{RLmap[r.repo]} $-$ \emph{URLmap[r.client].layers} \\
			oldLayers $\gets$ \emph{RLmap[r.repo]} $\bigcap$ \emph{URLmap[r.client].layers} \\
			
			%{\tiny\texttt{/* Restore slices if layer is deduped, otherwise fetch layer}} \\
			
			\emph{cache} $\leftarrow$ \texttt{Restore} newLayers.slices \\%\texttt{or} \texttt{Fetch} newLayers\\
			\If{URLmap[r.client, r.repo, oldLayers].rp $>$ $\theta_{rpc}$} 
			{ 
				 %\\
				%\emph{cache} $\leftarrow$ \texttt{Restore} oldLayers \\
				%{\tiny\texttt{/* Restore slices if layer is deduped, otherwise fetch layer}} \\
				\emph{cache} $\leftarrow$ \texttt{Restore} oldLayers.slices \\%\texttt{or} \texttt{Fetch} oldLayers\\
			}
		}
		\uElseIf{r = PUT layer}
		{
				\emph{cache} $\leftarrow$ \texttt{cache} \emph{r.layer} \\
				\texttt{update} \emph{RLmap[r.repo, r.layer]} \\
		}
		\uElseIf{r = GET layer} %GET
		{
			{\tiny\texttt{/* r.layer has not been deduplicated   /}} \\
				\eIf{r.layer in cache}
				{
					\emph{cache hit for layer} \\
					%\emph{serve from cache}
				} 
				{
					%{\tiny\texttt{/* Otherwise, it's a repull layer miss   /}} \\
					%\emph{serve from disk} \\
					cache $\gets$ \texttt{Fetch} \emph{r.layer} 
				}
		}
		\uElseIf{r = GET slice} %GET
		{
			{\tiny\texttt{/* r.layer has already been deduplicated   /}}
			
			\eIf{r.slice in cache}
			{
				%\emph{serve from cache} \\
				\emph{cache hit for slice} \\
			} 
			{
				%{\tiny\texttt{/* Otherwise, it's a repull layer miss   /}} \\
				cache $\gets$ \texttt{Restore} \emph{r.slice} 
			}
		}
		\texttt{update} \emph{URLmap[r.client, r.repo, r.layer]} \\
		\texttt{set} \emph{Timer[r.client, r.repo, layer]} \\
	%}

%	\SetKwFunction{Fsub}{Restore}
%	\SetKwProg{Fn}{Function}{:}{}
%
%	\Fn{\Fsub{r.slice}}{
%		%{\tiny\texttt{/* Otherwise, it's a repull layer miss   /}}\\
%		\eIf{files in r.slice are cached in file cache}
%		{
%			slice $\gets$ \texttt{RestoreSlice} \emph{r.slice} \texttt{From} \emph{file cache + disk} 
%		}
%		{
%			slice, $D_{rs}$ $\gets$ \texttt{RestoreSlice} \emph{r.slice} \texttt{From} \emph{disk} \\
%			\If{ $D_{rs} > \theta_{rsfc}$} 
%			{ 
%				\emph{file cache} $\gets$ \texttt{Cache} \texttt{Subsetof} \emph{r.slice.files}
%			}		
%		}
%	}

\end{algorithm}


