
\subsection{User behavior based layer preconstruction cache}
\label{sec:cache-design}
\subsubsection{User access patterns}
%\label{sec:design_cache_algori}
To improve our cache hit ratio for \texttt{pull} layer request, we propose a user-access-history-based prefetch algorithm. The algorithm
exploits the uniqueness of the registry's 
%image %structure
dataset hierarchy: repositories comprise a list of layers.
%or organization
%Users create repositories in the registry, \texttt{push} layers to their own repositories,
%and \texttt{pull} layers from their own repositories or other public repositories. 
When a user \emph{pulls} an image from a repository, it will first \texttt{pull} the manifest of the image~\cite{docker}~\cite{dockerworkload} and 
parse the manifest to get the layer digests,
then lookup each layer digest against a \emph{local layer digest index}.
After that it only \emph{pulls} the layers that has \emph{not been stored locally}.
%

\paragraph{User profiles}
Based on the above 
%behavior 
pattern and hierarchy, we can record the users' repository and layer access history. 
Theoretically, once a user issues a \texttt{pull} manifest from a repository, all the layers that belong to this repository but have not been \emph{pulled} by this user should be prefetched into the cache.
%when a new use connects to registry, we can prefetch all the layers that have been accessed by this user into cache ideally.
In this case, the cache hit ratio will reach 1.
%However, because there is a limit to the cache size, %we won't be able to fit all the active users' layers into cache.
%not all active user's layers will fit into the cache.
%%But we can prefetch active users' popular layers in the cache based on the historical access information.
%To mitigate this, we can only prefetch the active user's top requested layers based on the historical access information.

As shown in algorithm~\ref{alg:prefetch}, \sysname maintains two maps: a RLMap for recording layer-repository
relationship, and 
a URLMap for recording 
users' repository and layer access history information. 
For example, if a user~\emph{U} \emph{pulls} a layer~\emph{L} from a repository~\emph{R},
\sysname will add an new entry (\emph{U,L}) in URLMap.
%Each node records the following history information: (\emph{Get\_cnt}, \emph{Put\_cnt}, \emph{last\_access\_time}). a child node layer~\emph{L} to parent node~\emph{R}
While if a user~\emph{U} \emph{pushes} a  layer~\emph{L} to a repository~\emph{R},
\sysname~will add an new entry (\emph{R,L}) in RLMap. 
Note that to identify which layers are locally available for a user, 
we extract \emph{user end host address} (\emph{r.client}) 
%as shown in Algorithm~\ref{alg:prefetch}
from each request and define the user end host address as user,
and keep track of all layers that have been downloaded by \emph{r.client}. 
%Note that for a layer node, \emph{Put\_cnt} $=$ 1 or $=$ 0.
%When a GET or PUT layer request is received, \sysname~will update the URLMap of the associating user, repository, and layer. 
When either a GET manifest request is received or 
%a GET layer request is miss,
%a requested layer is not cached or prefetched  (
a miss on a GET layer request happens,
\sysname will lookup RLMap and get the requested repository's containing layers,
and compare against the layers that are already \emph{pulled} by the user by looking up URLMap,
%select a certain number of \emph{popular} layers from the client's 
%previously accessed layers by lookup 
%URLMap
then prefetch the layers that have not been \emph{pulled}. 
We set a timer for each cached layer and evict it when its timer is $>U_{thresh}$.
To incorporate the algorithm with \sysname,
we prefetch \texttt{slices} in parallel from backend servers,  
%dedup storage system,
buffer them in the layer buffer first, then evict them into the file cache after they \emph{cool down}.
%    for the user later accesses.
%To determine if a layer is a popular layer and need to be prefetched into cache,
%we only consider the layers that was recently accessed with a time period 
%We consider popular layers to be the layers accessed during the most recent~\emph{T\_thresh} 
%seconds?
%time period. In other words, the layers that satisfy the condition:
%\emph{current\_time} $-$ \emph{last\_access\_time} $<$ \emph{T\_thresh}.
%Then we calculate the layer popularity as: 
%$\omega_{pull} \times Pull\_cnt + \omega_{push} \times Push\_cnt$.
%Since recently \emph{pushed} layer has a higher chance to get \emph{pulled} in the future,
%we give a higher weight ($\omega_{push} > \omega_{pull}$) for the layer if it has a \emph{Push\_cnt} equal to 1. 

 
%We assume that users are independent with each other.

\paragraph{User "Pull manifest" request as an indicator}
\input{prefetch_algori}
\subsubsection{Layer preconstruction}

\subsubsection{Temporal trend}
\input{eviction_algori}

\paragraph{LRU of (user+repo) based cache eviction}

