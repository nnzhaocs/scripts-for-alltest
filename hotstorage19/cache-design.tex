
\subsection{Superfetch cache and preconstruct cache}
\label{sec:cache-design}

%In the following, we present our \sysname~\preconstructcachename design.
%Each \texttt{pull layer} request has a precedent \texttt{pull manifest} request.
%Upon receiving a \texttt{pull manifest} request, 
%\sysname~sends the updated \sysname~manifest to client.
%After receiving a \sysname~manifest, the client parses the manifest
%and sends either a \texttt{pull layer} request if the layer hasn't been deduplicated,
%or a list of \texttt{pull slice} requests if a list of corresponding slices presents in the manifest.
%Those \texttt{pull slice} requests will then be
%forwarded to all the registry servers that store the requested
%layer's slices as shown in Figure~\ref{fig:sys-overview}. 

%\input{fig-layer-preconstruct}

Based on the user access patterns observed in Section~\ref{sec:dataset-analysis},
\sysname predicts what layers will be accessed and prepares the layers before \texttt{pull} layer requests.
To improve the performance of primary cluster,
\sysname \emph{superfetches} the layers that will be accessed later into \textbf{superfetch cache}.
Moreover, 
to improve the layer restoring performance of deduplication cluster,
\sysname preconstructs layers before \texttt{pull} layer requests 
and put them into \textbf{preconstruct cache} to save restoring latency.

\paragraph{User access pattern based prediction}
The first user access pattern is that before a user sends a \texttt{pull} layer request,
the user will sends

%difference $\gets$ \emph{RLmap[r.repo]} $-$ \emph{ULmap[r.client]} \\
%intersection $\gets$ \emph{RLmap[r.repo]} $\bigcap$ \emph{ULmap[r.client]} \\
%
%targets $\leftarrow$ difference \\
%\ForEach{layer in intersection} 
%{ \If{ layer.rpcnt $>$ $\theta_{rpc}$}{
%		targets	$\leftarrow$ layer
%	}
%}

\paragraph{Superfetch cache  on primary cluster} 



\paragraph{Preconstruct cache on deduplication cluster}
\input{preconstruct_algori.tex}

Figure~\ref{fig:preconstruct}
shows how to preconstruct layers for later accesses.
When a \texttt{GET manifest} request is received by registry $A$,
it gets the requested repository information and client information from RLmap and ULmap respectively, 
and computes a list of target layers that will be accessed later by this client.
As shown, to preconstruct target layer $L1$, 
registry $A$ gets $L1$'s layer recipe from metadata database
and sends a notification of \texttt{preconstruct layer} $L1$ to 
$L1$'s restoring master: registry $B$. 
After receiving the notification, 
$B$ sends \texttt{get slice} requests to its peer workers: $C$ and $D$.
When $B$, $C$, and $D$ finished slice constructions for $L$,
three slices are concatenated by $B$ and saved in $B$'s layer diskcache. 

Algorithm~\ref{alg:prefetch} shows how to determine target layers 
based on observed user access pattern.
When a \texttt{GET manifest} request \emph{r} is received,
\sysname~gets a set of layers associated with the requested repository \emph{r.repo} from RLmap, 
denoted as $RLmap[r.repo]$.
Meanwhile, it also gets a set of layers associated with the client \emph{r.client} from ULmap,
denoted as $ULmap[r.client]$.
After that, it calculates a list of layers in the requested repository 
that have not been \texttt{pulled} by the client by
computing the difference set between $RLmap[r.repo]$ and $ULmap[r.client]$ (denoted as $difference$).
All the layers in $difference$ are included in target set.
\sysname also calculates a intersection set between 
$RLmap[r.repo]$ and $ULmap[r.client]$ (denoted as $intersection$).
The layers in $intersection$ are already pulled by client.
To determine whether a layer in $intersection$ will be
$repulled$ by client,
\sysname compares its repull count against a predefined threshold $\theta_{rpc}$.
If the layer's repull count is greater than $\theta_{rpc}$,
which means this layer will be repulled with high probability.
Thus, it is included in target layer set.

\sysname preconstructs layers before layer accesses to save layer construction time.

After D-servers receive the backup replicas,
\sysname will first update \emph{RLmap} with the layer and its associated repository, where
RLmap maps a \textbf{repository id} (i.e., repository name) to its containing layers 
as shown in Figure~\ref{fig:dedup-partition}.

When a~\texttt{pull} layer request is received, 
\sysname will first update \emph{ULmap}. 
ULmap records user access status,
which maps a \textbf{user Id} to its accessed layers with its corresponding access count,
where user id is defined as client request address.

For each layer in target set, 
\sysname gets the restoring master from its layer recipe,
and sends a notification of \texttt{preconsturct layer} to the master.
After the master receives the notification,
it first checks if the requested layer is in the preconstruct cache.
If not, 
it starts layer construction and saves the preconstructed layer in the preconstruct cache.
 
%and gets two groups of layers: \emph{newLayers} and \emph{oldLayers}.
%\emph{newLayers} means the layers that belongs to \emph{r.repo} but haven't been pulled by client \emph{r.client}.
%While \emph{oldLayers} means the layers that belongs to both of them.
%\preconstructcachename~will first restore the slices for \emph{newLayers} because 
%they are not locally available to \emph{r.client}.    
%For \emph{oldLayers}, 
%if an \emph{oldLayer} has a higher repull count and \emph{r.repo} as well as \emph{r.client} have a higher repulling probability,
%then \preconstructcachename~will restore its slices and cache them.
%If a \emph{PUT} layer request is received, RLmap and URLmap will be updated accordingly.
%
%If a \emph{GET} layer request is received, it means that \emph{r.layer} has not been deduplicated.
%\preconstructcachename~will cache \emph{r.layer} if cache miss happens on \emph{GET} layer request as shown in Algorithm~\ref{alg:prefetch}.
%If a \emph{GET} slice request is received, meaning that \emph{r.layer} has already been deduplicated into deduplicated slices,
%\preconstructcachename~will check if the requested \emph{r.slice} exists in the cache.
%If not,
%\dedupname system~will start restoring \emph{r.slice} and also put it in cache.
%In the end, \preconstructcachename~will update URLmap with corresponding repull count and repull probability.
\paragraph{Preconstruct cache eviction}
To exploit the temporal trend of clients and repositories, 
\sysname sets timer for each cached layers.
Once a layer is expired,
it will be simply deleted from the preconstruct cache.

Preconstruct cache replacement is triggered when the free space in the cache is
lower than threshold $\theta_{C}$.
As shown in Algorithm~\ref{alg:eviction}, 
\sysname~maintains a LFRU list~\cite{xxx} of cached layers to exploit 
layer temporal trend.
If the free space is low,
\sysname~selects the least frequent recently used layer to evict.


\input{eviction_algori}

%\input{fig-repull-analysis}





