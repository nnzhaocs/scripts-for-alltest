
\subsection{Layer preconstruction}
\label{sec:cache-design}

%In the following, we present our \sysname~\preconstructcachename design.
%Each \texttt{pull layer} request has a precedent \texttt{pull manifest} request.
%Upon receiving a \texttt{pull manifest} request, 
%\sysname~sends the updated \sysname~manifest to client.
%After receiving a \sysname~manifest, the client parses the manifest
%and sends either a \texttt{pull layer} request if the layer hasn't been deduplicated,
%or a list of \texttt{pull slice} requests if a list of corresponding slices presents in the manifest.
%Those \texttt{pull slice} requests will then be
%forwarded to all the registry servers that store the requested
%layer's slices as shown in Figure~\ref{fig:sys-overview}. 

\input{fig-layer-preconstruct}

Based on the observations made in xxxx,
\sysname preconstructs layers before layer accesses to save layer construction time.

\paragraph{User behavior based layer preconstruction}
\input{preconstruct_algori.tex}

Figure~\ref{fig:preconstruct}
shows how to preconstruct layers for later accesses.
When a \texttt{GET manifest} request is received by registry $A$,
it gets the requested repository information and client information from RLmap and ULmap respectively, 
and computes a list of target layers that will be accessed later by this client.
As shown, to preconstruct target layer $L1$, 
registry $A$ gets $L1$'s layer recipe from metadata database
and sends a notification of \texttt{preconstruct layer} $L1$ to 
$L1$'s restoring master: registry $B$. 
After receiving the notification, 
$B$ sends \texttt{get slice} requests to its peer workers: $C$ and $D$.
When $B$, $C$, and $D$ finished slice constructions for $L$,
three slices are concatenated by $B$ and saved in $B$'s layer diskcache. 

Algorithm~\ref{alg:prefetch} shows how to determine target layers 
based on observed user access pattern.
When a \texttt{GET manifest} request \emph{r} is received,
\sysname~gets a set of layers associated with the requested repository \emph{r.repo} from RLmap, 
denoted as $RLmap[r.repo]$.
Meanwhile, it also gets a set of layers associated with the client \emph{r.client} from ULmap,
denoted as $ULmap[r.client]$.
After that, it calculates a list of layers in the requested repository 
that have not been \texttt{pulled} by the client by
computing the difference set between $RLmap[r.repo]$ and $ULmap[r.client]$ (denoted as $difference$).
All the layers in $difference$ are included in target set.
\sysname also calculates a intersection set between 
$RLmap[r.repo]$ and $ULmap[r.client]$ (denoted as $intersection$).
The layers in $intersection$ are already pulled by client.
To determine whether a layer in $intersection$ will be
$repulled$ by client,
\sysname compares its repull count against a predefined threshold $\theta_{rpc}$.
If the layer's repull count is greater than $\theta_{rpc}$,
which means this layer will be repulled with high probability.
Thus, it is included in target layer set.

For each layer in target set, 
\sysname gets the restoring master from its layer recipe,
and sends a notification of \texttt{preconsturct layer} to the master.
After the master receives the notification,
it first check if the requested layer is in the diskcache.
If not, 
it starts layer construction and saves the preconstructed layer in diskcache.
 
%and gets two groups of layers: \emph{newLayers} and \emph{oldLayers}.
%\emph{newLayers} means the layers that belongs to \emph{r.repo} but haven't been pulled by client \emph{r.client}.
%While \emph{oldLayers} means the layers that belongs to both of them.
%\preconstructcachename~will first restore the slices for \emph{newLayers} because 
%they are not locally available to \emph{r.client}.    
%For \emph{oldLayers}, 
%if an \emph{oldLayer} has a higher repull count and \emph{r.repo} as well as \emph{r.client} have a higher repulling probability,
%then \preconstructcachename~will restore its slices and cache them.
%If a \emph{PUT} layer request is received, RLmap and URLmap will be updated accordingly.
%
%If a \emph{GET} layer request is received, it means that \emph{r.layer} has not been deduplicated.
%\preconstructcachename~will cache \emph{r.layer} if cache miss happens on \emph{GET} layer request as shown in Algorithm~\ref{alg:prefetch}.
%If a \emph{GET} slice request is received, meaning that \emph{r.layer} has already been deduplicated into deduplicated slices,
%\preconstructcachename~will check if the requested \emph{r.slice} exists in the cache.
%If not,
%\dedupname system~will start restoring \emph{r.slice} and also put it in cache.
%In the end, \preconstructcachename~will update URLmap with corresponding repull count and repull probability.


\paragraph{Layer diskcache eviction}
To exploit the temporal trend of clients and repositories, 
\sysname sets timer for each cached layers.
Once a layer is expired,
it will be simply deleted from diskcache.

Layer diskcache replacement is triggered when the free space in diskcache is
lower than threshold $\theta_{C}$.
As shown in Algorithm~\ref{alg:eviction}, 
\sysname~maintains a LFRU list~\cite{xxx} of cached layers to exploit 
layer temporal trend.
If the free space is low,
\sysname~selects the least frequent recently used layer to evict.


\input{eviction_algori}

%\input{fig-repull-analysis}





