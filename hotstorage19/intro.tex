\section{Introduction}
\label{sec:intro}

%
% Introduction structure:
%
% 1. Containerization background, benefits, and popularity.
%
% 2. Background on container images and registry storage;
%    large number of images => high storage requirements for the registries.
%
% 3. Significant amount of unharvested duplication across images.
%    Traditional dedup cannot be applied directly - need to decompress
%    Even with decompression, things do not work well: perfomance overhead
%
% 4. Sift's idea
%
% 5. Evaluation: how and what we got
%

%%%
% 1. Background, benefits, and popularity of containerization;
%%%

\emph{Container runtimes} such as Docker~\cite{docker} 
%and \mbox{CRI-O}~\cite{cri-o}
leverage Linux kernel's namespaces~\cite{namespaces} and cgroups~\cite{cgroups}
to efficiently virtualize computational resources.
%
Unlike the hardware-virtualization-based Virtual Machines
(VMs)~\cite{adams2006comparison}, containers residing on the same host share
the single Operating System (OS) kernel, which yields virtual environments with
lower overheads and faster starts~\cite{7819678}.
%
Further, container runtimes introduce portable, self-contained \emph{container
images} and are surrounded by a rich ecosystem of technologies that automate
and accelerate application development, deployment, and
management~\cite{cncfprojects}.

Given the benefits of containers, it is not surprising that they have seen a
remarkable advancement in modern cloud environments.
%
The rapid spread of containers is further fueled by the growing popularity of
microservices~\cite{wolff2016microservices},
%design methodology
for which containers act as an imperative enabler.
%
By now all major cloud platforms endorse containers as a core cloud deployment
technology~\cite{googlecengine,azurec,ibmkube,awscont}.
%
According to some surveys, in 2018 about 21\% of enterprise hosts are already
managed by Docker and the ratio is consistently growing by about 5\%
annually~\cite{20percentdocker}.

%%%
% 2. Background on container images and registry storage;
%    large number of images => high storage requirements for the registries;
%%%

An application's container image includes the executable of the application
along with a complete set of its dependencies---other executables, libraries,
configuration and data files.
%
Images have a layered structure; when building an image with Docker each
executed command, such as \texttt{apt-get install}, forms a new \emph{layer} on
top of the previous one~\cite{dockerfile}.
%
Each layer contains the files that the command has modified or added during its
execution.
%
A layer can be shared between multiple images.
%
Docker leverages unification file systems~\cite{docker-driver-eval} to
efficiently merge layers into a single file system tree when starting a container.

To store and distribute container images Docker relies on image
\emph{registries} (e.g., Docker Hub~\cite{docker-hub}).
%
Docker clients can push images to or pull them from the registries as needed.
%
On the registry side each layer is stored as a compressed tarball and
identified by a content-based address.
%
Docker registry supports various storage backends for saving and retrieving
layers; a typical large-scale setup stores each layer as an object in an object
store~\cite{s3,swift}.

As the container market continues to expand, Docker registries manage a
growing number of image layers.
%
Some conservative estimates show that in the spring of 2019 Docker Hub alone
stored at least 2 million \emph{public} images of 1~PB size in
total~\cite{skourtis2019carving,dedupanalysis}. 
%
We believe that this is just the tip of an iceberg and the number of
\emph{private} images is significantly higher.
%
Other popular public
registries~\cite{amazon-ecr,jfrog-artifactory,azure-cr,google-cr}, as well as
on-prem registry deployments in large organizations, experience the same
surge of container images.
%
To keep up with the demand and provide adequate performance levels,
organizations spend an increasing amount of their storage and networking
infrastructure on operating image registries.
%
%
%%%
% 3. Significant amount of unharvested duplication across images.
%%%

The recent analysis of
% $47$~TB ($167$~TB uncompressed)
Docker Hub image dataset showed that about $97$\% of files across layers are
duplicates~\cite{dedupanalysis}.
%
Such high redundancy is not surprising: after all every Docker image has to be
self-sufficient by definition and is typically built by developers without much
coordination with others.
%
Registry storage backends exacerbate the redundancy further due to the
replication they perform to improve images durability and
availability~\cite{Bonvin:2010:SFS:1807128.1807162}.
%
For instance, assuming the 3-way replication, the number of duplicate files in the
Docker Hub dataset reaches 99\%.
%
And yet, existing registry deployments do not exploit high data redundancy
across layers to make the service more efficient.

%%%
% 4. Sift's idea
%     Even with decompression, things do not work well: perfomance overhead.
%%%

In this paper we propose \emph{\sysname}, the first Docker registry that
supports deduplication.
%
The na\"{i}ve application of deduplication to the registry---decompressing
layers and storing individual files in content-addressable storage---introduces
prohibitive overheads.
%
The slowdowns caused by layers reconstruction during image pulls are especially
harmful because they contribute directly to the start times of containers.
%
Our experiments showed that on average na\"{i}ve deduplication increases layer
download latencies by 2.5$\times$ compared to the original registry.

%
\sysname's design is tailored to Docker registry environments and workloads to
reduce deduplication overhead.
%
\sysname exploits two kinds of redundancies: 1)~redundant data across layers,
and 2)~redundancy caused by the replication in the storage backend.
%
First, \sysname keeps a fixed number (0--3) of layer replicas as-is, without
decompressing and deduplicating them.
%
Accesses to these replicas do not experience deduplication overhead.
%
The remaining layer replicas (0--3) are decompressed and deduplicated.
%
Second, \sysname allows to deduplicate less frequently accessed layers more
aggressively than the popular layers.
%
Third, \sysname monitors and exploits user access patterns and preconstructs
layers before layer download requests arrive.
%
Finally, during layer deduplication \sysname groups files in \emph{slices} to
enable high-speed parallel streaming layer reconstruction.
%
%Depending on the user and environment requirements for performance, storage
%savings, and durability users can configure...

%%%
% 4. Sift's evaluation
%%%

\VT{will populate as eval is ready}

%We implemented and deployed \sysname on a 21-node cluster and evaluated with
%real-world workloads and real layers.
%
%The evaluation results show that uses a cache that takes into consideration the
