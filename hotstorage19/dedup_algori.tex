\subsection{User-based Cache Algorithm}
\label{sec:design_cache_algori}

\input{cache_algori.tex}

We use our observations of the user access pattern to guide our cache replacement
since the user's active time is more predictable as discussed in Section~\ref{xxx}.
In~\cref{sec:design}, the incoming \texttt{push} layer requests are first buffered in the layer buffer and later evicted to the file cache.
If there is a \texttt{pull} layer request miss in both the layer buffer and the file cache, 
\sysname~will fetch the layer from backend storage system and store it in the layer buffer.
When a cache pressure happens in both the file cache and the layer buffer caused by shortage of free space.
The layer buffer or the file cache will simply evict or delete some layers or files and reclaim space.
Since our layer buffer and file cache both share the same cache replacement algorithm, we only present
our user-based cache replacement algorithm for the layer buffer  as shown in Algorithm~\ref{alg:cache}.

Free space in the layer buffer is too low if ($free\_buffer$ $<$ $S_{thresh}$). 
\sysname~will free the buffer space used by inactive users. 
\sysname~maintains two LRU lists: a LRU list of active users and
a LRU list of recently accessed layers, that we call \emph{UsrLRU} and \emph{LayerLRU}, respectively.
At first, \sysname~will select the least active user from \emph{UsrLRU}.
Next, \sysname~will reversely iterate \emph{UsrLRU} until it finds a layer that is exclusively owned by that least active user, 
\sysname~then evicts the layer from layer buffer. 
 Note that layers are shared among different active users.
 \sysname~continues with evictions until the free space in the layer buffer is above the specified capacity threshold.
 
%iteratively removes the least active users along with the least recently accessed layers 
% that exclusively owned by these users from the two LRU lists and evict the layers from layer buffer.
%, then   


